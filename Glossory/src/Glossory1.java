import java.util.Comparator;

import components.map.Map;
import components.map.Map3;
import components.queue.Queue;
import components.queue.Queue3;
import components.set.Set;
import components.set.Set3;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Project 10: Glossory.
 *
 * @author Nicholas Trambitas
 *
 */

public final class Glossory1 {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private Glossory1() {
    }

    /**
     *
     * Create a comparator that will be used to sort the queue of type string.
     *
     */
    private static class StringLT implements Comparator<String> {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    /**
     * Outputs the "opening" tags in the generated index HTML file. These are
     * the expected elements generated by this method:
     *
     * <html> <head> <title>the title as the page title
     * <h1>the page title</h1>
     * <h2>index</h2>
     *
     * ul start the unordered list
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    public static void outputIndexHeader(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        //print basic html tags to file
        out.println("<html>");
        out.println("<head>");
        out.println("<title>Glossory</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h1>Glossory</h1>");
        out.println("<hr>");
        out.println("<h2>Index</h2>");

        //set up the ordered list
        out.println("<ul>");

    }

    /**
     * Outputs the generated definition HTML file. These are the expected
     * elements generated by this method:
     *
     * <html> <head> <title>the title as the page title *
     * <h1>the page title</h1>
     * <h2>index</h2>
     *
     * @param directory
     *            the directory as to where to store the created page
     * @param terms
     *            the queue containing the terms
     * @param dictionary
     *            the map linking each term with its definition
     * @param words
     *            the set containing the terms (the same contents as the queue)
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    public static void outputDefinitionPage(String directory,
            Queue<String> terms, Map<String, String> dictionary,
            Set<String> words) {

        //pull the the term from the queue, set it as the page title,
        String title = terms.dequeue();

        //create the page
        SimpleWriter out = new SimpleWriter1L(
                directory + "/" + title + ".html");

        //print basic html tags to file
        out.println("<html>");
        out.println("<head>");
        out.println("<title>" + title + "</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h1 style=\"color:red;\">" + "<em>" + title + "</em>"
                + "</h1>");

        //get the definiton of the word
        String definition = dictionary.value(title);
        int pos = 0;

        //run through the entire string of the definition.
        //this will check if there are other terms in the definition
        //that is also in the glossory

        while (pos < definition.length()) {

            // create separatorSet with all possible separators
            Set<Character> separatorSet = new Set3<>();
            separatorSet.add(' ');
            separatorSet.add(',');
            separatorSet.add('\t');
            separatorSet.add('\n');
            separatorSet.add('!');
            separatorSet.add('.');
            separatorSet.add('?');
            separatorSet.add('/');
            separatorSet.add(':');
            separatorSet.add(';');

            // returns one word from the definition
            String element = nextWordOrSeparator(definition, pos, separatorSet);

            //update pos so it accounts for next word
            pos += element.length();

            //check if word (element) is also a term in glossory
            boolean inGlossory = words.contains(element);

            if (inGlossory) {

                //print out the definition up to the element
                String str1 = definition.substring(0,
                        definition.indexOf(element));
                //print the element along with its link
                String str2 = "<a href=\"" + element + ".html\">" + element
                        + "</a>";

                //print the end of the definition after the inserted link
                String str3 = definition.substring(
                        definition.indexOf(element) + element.length());

                //final definition to print to page
                definition = str1 + str2 + str3;
            }
        }

        //print the definition to the page
        out.println("<p>" + definition + "</p>");

        //restore the queue
        terms.enqueue(title);

        //end the page
        out.println("<hr/>");
        out.println("<p>Return to <a href=\"index.html\">index</a>.</p>");
        out.println("</body>");
        out.println("</html>");

        //close scanner
        out.close();

    }

    /**
     * Outputs the "closing" tags in the generated index HTML file. These are
     * the expected elements generated by this method:
     *
     * (<ul, body, html/>
     *
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void outputIndexFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Outputs the sorted terms in the generated index HTML file. These are the
     * expected elements generated by this method:
     *
     * <li>term</li>
     *
     *
     * @param out
     *            the output stream
     * @param terms
     *            queue which stores the terms that are to be printed
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void outputIndexTerms(SimpleWriter out, Queue<String> terms) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        Queue<String> temp = new Queue3<>();
        while (terms.length() != 0) {
            String removed = terms.dequeue();
            out.println("<li>");
            out.println("<a href=\"" + removed + ".html\">" + removed + "</a>");
            out.println("</li>");
            temp.enqueue(removed);

        }

        terms.transferFrom(temp);
    }

    /**
     * Reads the input file and returns a sorted queue and creates a map
     * dictionary of all the terms defined inside the file.
     *
     *
     *
     * @param in
     *            the input stream
     * @param terms
     *            the queue to be populated and sorted
     * @param dictionary
     *            map linking the words and definitions
     *
     *
     * @updates queue, dictionary
     *
     *
     * @requires in.is_open
     *
     * @ensures terms are inserted into the queue and are sorted
     */
    public static void getTerm(SimpleReader in, Queue<String> terms,
            Map<String, String> dictionary) {
        assert in != null : "Violation of: in is not null";
        assert in.isOpen() : "Violation of: in.is_open";
        String key = "";
        String definition = "";

        while (!in.atEOS()) {
            String input = in.nextLine();
            if (!input.isBlank() && !input.contains(" ")) {
                key = input;
                terms.enqueue(key);

            } else if (!input.isBlank()) {
                definition += input;

            } else {

                dictionary.add(key, definition);
                definition = "";
            }
        }
        //needed in order to read the last term of the text file
        dictionary.add(key, definition);

        //sort the queue in alphabetical order
        Comparator<String> cs = new StringLT();
        terms.sort(cs);

    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */

    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        int i = position;
        //if the character @ position is in the set,
        //iterate through the set until you come upon a value not in the set
        //adding all the values that are in the set to a string
        if (separators.contains(text.charAt(i))) {
            while (separators.contains(text.charAt(i))) {
                i++;
            }
            //if the opposite is true, vice versa
        } else {
            while (i < text.length() && !separators.contains(text.charAt(i))) {
                i++;
            }

        }

        return text.substring(position, i);
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        SimpleReader in = new SimpleReader1L();
        SimpleWriter out = new SimpleWriter1L();

        out.println("Input file location:");
        String fileInput = in.nextLine();
        SimpleReader inText = new SimpleReader1L(fileInput);

        out.println("Enter the directory on where to save your glossory: ");
        String directory = in.nextLine();
        SimpleWriter outputIndex = new SimpleWriter1L(
                directory + "/index.html");

        //generate index.html
        outputIndexHeader(outputIndex);

        //set up the dictionary and print the terms on index.html
        Queue<String> terms = new Queue3<>();
        Map<String, String> dictionary = new Map3<>();
        Set<String> words = new Set3<>();

        getTerm(inText, terms, dictionary);

        //transfer the terms from queue to a set
        for (int i = 0; i < terms.length(); i++) {
            String temp = terms.dequeue();
            words.add(temp);
            terms.enqueue(temp);
        }

        outputIndexTerms(outputIndex, terms);

        outputIndexFooter(outputIndex);

        //generate accompanying definition pages for all the terms
        for (int i = 0; i < terms.length(); i++) {
            outputDefinitionPage(directory, terms, dictionary, words);

        }

        /*
         * Close input and output streams
         */
        in.close();
        inText.close();
        out.close();
        outputIndex.close();
    }

}
